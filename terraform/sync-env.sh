#!/usr/bin/env bash
set -euo pipefail

TF_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
REPO_ROOT="$(cd "$TF_DIR/.." && pwd)"
BACKEND_DIR="$REPO_ROOT/backend"
FRONTEND_DIR="$REPO_ROOT/frontend"

if [[ ! -d "$BACKEND_DIR" || ! -d "$FRONTEND_DIR" ]]; then
  echo "This script must be run inside the PoliTopics repo (backend/ and frontend/ missing)." >&2
  exit 1
fi

if ! command -v terraform >/dev/null 2>&1; then
  echo "terraform command not found. Please install Terraform first." >&2
  exit 1
fi

if ! command -v python3 >/dev/null 2>&1; then
  echo "python3 command not found. Please install Python 3 to parse outputs." >&2
  exit 1
fi

pushd "$TF_DIR" >/dev/null
if ! TF_OUTPUT_JSON="$(terraform output -json 2>/dev/null)"; then
  echo "Unable to read Terraform outputs. Run 'terraform apply' first." >&2
  popd >/dev/null
  exit 1
fi
popd >/dev/null

export TF_OUTPUT_JSON

python3 - "$REPO_ROOT" "$BACKEND_DIR" "$FRONTEND_DIR" <<'PY'
import datetime
import json
import os
import pathlib
import sys
from urllib.parse import urlparse

MARKER = "# Generated by terraform/sync-env.sh"

if "TF_OUTPUT_JSON" not in os.environ:
  raise SystemExit("Missing TF_OUTPUT_JSON data.")

try:
  outputs = json.loads(os.environ["TF_OUTPUT_JSON"])
except json.JSONDecodeError as err:
  raise SystemExit(f"Failed to parse Terraform outputs: {err}") from err

root = pathlib.Path(sys.argv[1])
backend_dir = pathlib.Path(sys.argv[2])
frontend_dir = pathlib.Path(sys.argv[3])


def read_output(name):
  block = outputs.get(name)
  if not block:
    raise SystemExit(f"Terraform output '{name}' not found. Ensure it exists in outputs.tf.")
  return block.get("value")


def extract_name(value):
  if isinstance(value, str):
    return value
  if isinstance(value, dict):
    return value.get("name") or value.get("id") or ""
  return str(value or "")


def extract_attr(value, key):
  if isinstance(value, dict):
    return value.get(key) or ""
  return ""


def parse_region_from_arn(arn):
  if not arn:
    return ""
  parts = arn.split(":")
  return parts[3] if len(parts) > 3 else ""


def infer_environment(api_url, table_name):
  if api_url:
    parsed = urlparse(api_url)
    path = parsed.path.rstrip("/")
    if path:
      segment = path.rsplit("/", 1)[-1]
      if segment:
        return segment
  if table_name and "-" in table_name:
    candidate = table_name.rsplit("-", 1)[-1]
    return candidate
  return "localstack"


table_block = read_output("article_table")
payload_block = read_output("article_payload_bucket")
frontend_block = read_output("frontend_bucket")
api_url = read_output("backend_api_url")

table_name = extract_name(table_block)
payload_bucket = extract_name(payload_block)
frontend_bucket = extract_name(frontend_block)
table_arn = extract_attr(table_block, "arn")
payload_arn = extract_attr(payload_block, "arn")
frontend_website = extract_attr(frontend_block, "website")

region = parse_region_from_arn(table_arn) or "ap-northeast-3"
environment = infer_environment(api_url, table_name) or "localstack"
timestamp = datetime.datetime.utcnow().isoformat(timespec="seconds") + "Z"


def escape_value(value):
  value = "" if value is None else str(value)
  return value.replace("\\", "\\\\").replace('"', '\\"')


def render_lines():
  backend_lines = [
    f'ENV="{escape_value(environment)}"',
    f'POLITOPICS_TABLE="{escape_value(table_name)}"',
    f'POLITOPICS_ARTICLE_BUCKET="{escape_value(payload_bucket)}"',
    f'AWS_REGION="{escape_value(region)}"',
  ]
  if environment == "localstack":
    backend_lines.append('LOCALSTACK_URL="http://localstack:4566"')
  backend_lines.extend(
    [
      "",
      f"# Article table ARN: {table_arn or 'n/a'}",
      f"# Article payload bucket ARN: {payload_arn or 'n/a'}",
    ]
  )

  frontend_lines = [
    f'NEXT_PUBLIC_API_BASE_URL="{escape_value(api_url)}"',
    "",
    f"# Frontend bucket: {frontend_bucket or 'n/a'}",
  ]
  if frontend_website:
    frontend_lines.append(f"# Frontend website endpoint: http://{frontend_website}")
  return backend_lines, frontend_lines


def ensure_writable(path):
  if path.exists():
    with path.open("r", encoding="utf-8") as existing:
      first_line = existing.readline().strip()
      if first_line != MARKER:
        raise SystemExit(
          f"Refusing to overwrite {path}. Move or delete the file (it does not look auto-generated)."
        )
  else:
    path.parent.mkdir(parents=True, exist_ok=True)


def write_env(path, lines):
  ensure_writable(path)
  payload = "\n".join([MARKER, f"# Last updated: {timestamp}", ""] + lines) + "\n"
  path.write_text(payload, encoding="utf-8")


backend_lines, frontend_lines = render_lines()

backend_env = backend_dir / ".env"
frontend_env = frontend_dir / ".env.local"

write_env(backend_env, backend_lines)
write_env(frontend_env, frontend_lines)

rel_backend = backend_env.relative_to(root)
rel_frontend = frontend_env.relative_to(root)

print(f"Wrote {rel_backend}")
print(f"Wrote {rel_frontend}")
print("You can re-run this script any time after terraform apply to refresh the env files.")
PY
